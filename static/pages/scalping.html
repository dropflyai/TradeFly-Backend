<div class="page-header">
    <h1 class="page-title">âš¡ Scalping Signals</h1>
    <p class="page-subtitle">Fast 0-7 DTE options plays | Quick entries and exits</p>
</div>

<!-- Stats Summary -->
<div class="stats-grid">
    <div class="stat-card">
        <div class="stat-label">Active Signals</div>
        <div class="stat-value" id="scalp-active-count">-</div>
    </div>
    <div class="stat-card">
        <div class="stat-label">Avg Confidence</div>
        <div class="stat-value" id="scalp-avg-confidence">-</div>
    </div>
    <div class="stat-card">
        <div class="stat-label">In Paper Trading</div>
        <div class="stat-value" id="scalp-paper-count">-</div>
    </div>
    <div class="stat-card">
        <div class="stat-label">Win Rate (7d)</div>
        <div class="stat-value stat-up" id="scalp-win-rate">-</div>
    </div>
</div>

<!-- Controls -->
<div class="card mb-3">
    <div style="display: flex; justify-content: space-between; align-items: center;">
        <div>
            <label style="color: var(--text-secondary); margin-right: 1rem;">Min Confidence:</label>
            <select id="scalp-min-confidence" style="padding: 0.5rem; border-radius: 0.375rem; background: var(--dark-bg); color: var(--text-primary); border: 1px solid var(--border-color);">
                <option value="0.80">80%</option>
                <option value="0.85" selected>85%</option>
                <option value="0.90">90%</option>
                <option value="0.95">95%</option>
            </select>
        </div>
        <button class="btn btn-primary" id="scalp-refresh-btn">ðŸ”„ Refresh Signals</button>
    </div>
</div>

<!-- Signals Grid -->
<div id="scalp-signals-container">
    <div class="loading">Loading scalping signals...</div>
</div>

<script>
// Scalping Page Logic
const ScalpingPage = {
    signals: [],
    minConfidence: 0.85,

    async init() {
        console.log('Initializing Scalping page');

        // Set up event listeners
        document.getElementById('scalp-refresh-btn').addEventListener('click', () => this.loadSignals());
        document.getElementById('scalp-min-confidence').addEventListener('change', (e) => {
            this.minConfidence = parseFloat(e.target.value);
            this.loadSignals();
        });

        // Load initial data
        await this.loadSignals();
        await this.loadStats();

        // Auto-refresh every 30 seconds
        setInterval(() => this.loadSignals(), 30000);
    },

    async loadSignals() {
        try {
            const response = await fetch(`/api/options/signals?strategy=SCALPING&min_confidence=${this.minConfidence}&max_results=20`);
            const rawSignals = await response.json();

            // Transform API response to flatten nested structure
            const signals = rawSignals.map(s => ({
                ...s,
                symbol: s.contract?.symbol || 'N/A',
                strike: s.contract?.strike || 0,
                suggested_entry: s.entry_price || 0,
                delta: s.contract?.greeks?.delta || 0,
                iv_rank: s.contract?.iv_metrics?.iv_rank || 0,
                dte: this.calculateDTE(s.contract?.expiration),
                target_profit_percent: this.calculateProfitPercent(s.entry_price, s.target_price),
                stop_loss_percent: this.calculateProfitPercent(s.entry_price, s.stop_loss)
            }));

            this.signals = signals;
            this.renderSignals(signals);
        } catch (error) {
            console.error('Error loading signals:', error);
            document.getElementById('scalp-signals-container').innerHTML = '<div class="empty-state">Error loading signals</div>';
        }
    },

    calculateDTE(expirationDate) {
        if (!expirationDate) return 0;
        const expiry = new Date(expirationDate);
        const now = new Date();
        const diffTime = Math.abs(expiry - now);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return diffDays;
    },

    calculateProfitPercent(entry, target) {
        if (!entry || entry === 0) return 0;
        return ((target - entry) / entry) * 100;
    },

    async loadStats() {
        try {
            const response = await fetch('/api/paper/stats');
            const stats = await response.json();

            document.getElementById('scalp-active-count').textContent = this.signals.length;
            document.getElementById('scalp-avg-confidence').textContent =
                this.signals.length > 0
                    ? (this.signals.reduce((sum, s) => sum + s.confidence, 0) / this.signals.length * 100).toFixed(0) + '%'
                    : '0%';

            // Count scalping signals in paper trading
            const scalpingInPaper = stats.strategies?.SCALPING?.sample_size || 0;
            document.getElementById('scalp-paper-count').textContent = scalpingInPaper;

            // Win rate from paper trading stats
            const winRate = stats.strategies?.SCALPING?.win_rate || 0;
            document.getElementById('scalp-win-rate').textContent = (winRate * 100).toFixed(1) + '%';
        } catch (error) {
            console.error('Error loading stats:', error);
        }
    },

    renderSignals(signals) {
        const container = document.getElementById('scalp-signals-container');

        if (!signals || signals.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">âš¡</div>
                    <p>No scalping signals found at ${(this.minConfidence * 100).toFixed(0)}% confidence</p>
                    <p class="text-muted">Try lowering the minimum confidence threshold</p>
                </div>
            `;
            return;
        }

        container.innerHTML = signals.map(signal => this.renderSignalCard(signal)).join('');

        // Attach event listeners to quick-add buttons
        signals.forEach(signal => {
            const btn = document.getElementById(`quick-add-${signal.signal_id}`);
            if (btn) {
                btn.addEventListener('click', () => this.quickAddToPaper(signal));
            }
        });

        // Initialize mini charts for each signal
        signals.forEach(signal => {
            this.loadMiniChart(signal);
        });
    },

    async loadMiniChart(signal) {
        const chartId = `chart-${signal.signal_id}`;
        const container = document.getElementById(chartId);

        if (!container) {
            console.warn(`Chart container ${chartId} not found`);
            return;
        }

        try {
            // Fetch price data for the symbol
            const priceData = await TradeFlyCharts.fetchPriceData(signal.symbol, '1Day', 30);

            if (!priceData || priceData.length === 0) {
                // Use demo data if real data not available
                console.log(`Using demo data for ${signal.symbol}`);
                const demoData = TradeFlyCharts.generateDemoData(signal.contract?.underlying_price || 100, 30);

                const chart = TradeFlyCharts.createMiniChart(chartId, signal.symbol, {
                    width: container.clientWidth,
                    height: 150
                });

                if (chart) {
                    chart.updateData(demoData.candleData);
                }
                return;
            }

            // Create chart with real data
            const chart = TradeFlyCharts.createMiniChart(chartId, signal.symbol, {
                width: container.clientWidth,
                height: 150
            });

            if (chart) {
                // Transform and load data
                const { candleData } = TradeFlyCharts.transformPriceData(priceData);
                chart.updateData(candleData);

                // Add entry/target/stop price lines
                if (signal.contract?.underlying_price) {
                    const currentPrice = signal.contract.underlying_price;
                    // These are visual markers, not functional price lines
                    // Price lines would need to be added to the chart instance
                }
            }
        } catch (error) {
            console.error(`Error loading chart for ${signal.symbol}:`, error);

            // Fallback to demo data
            const demoData = TradeFlyCharts.generateDemoData(signal.contract?.underlying_price || 100, 30);
            const chart = TradeFlyCharts.createMiniChart(chartId, signal.symbol, {
                width: container.clientWidth,
                height: 150
            });

            if (chart) {
                chart.updateData(demoData.candleData);
            }
        }
    },

    renderSignalCard(signal) {
        const confidenceClass = signal.confidence >= 0.90 ? 'confidence-high' : 'confidence-medium';
        const actionColor = signal.action.includes('CALL') ? 'var(--success-color)' : 'var(--danger-color)';

        // Calculate match score based on user preferences
        const matchScore = this.calculateMatchScore(signal);
        const matchClass = matchScore >= 90 ? 'match-perfect' : matchScore >= 75 ? 'match-good' : matchScore >= 60 ? 'match-ok' : 'match-poor';
        const matchLabel = matchScore >= 90 ? 'Perfect Match' : matchScore >= 75 ? 'Good Match' : matchScore >= 60 ? 'Partial Match' : 'Poor Match';

        return `
            <div class="signal-card">
                <div class="signal-header">
                    <div>
                        <div class="signal-symbol">${signal.symbol}</div>
                        <div class="text-muted" style="font-size: 0.875rem;">${signal.strategy}</div>
                    </div>
                    <div style="display: flex; gap: 0.5rem; align-items: center;">
                        <div class="match-badge ${matchClass}" title="${matchLabel}">
                            ${matchScore}% Match
                        </div>
                        <div class="signal-confidence ${confidenceClass}">
                            ${(signal.confidence * 100).toFixed(0)}% Confidence
                        </div>
                    </div>
                </div>

                <!-- Mini Price Chart -->
                <div style="margin: 1rem 0; padding: 0.75rem; background: rgba(15, 23, 42, 0.5); border-radius: 0.5rem;">
                    <div id="chart-${signal.signal_id}" style="width: 100%; height: 150px;"></div>
                </div>

                <div class="signal-details">
                    <div class="signal-detail">
                        <span class="signal-detail-label">Action:</span>
                        <span class="signal-detail-value" style="color: ${actionColor};">${signal.action}</span>
                    </div>
                    <div class="signal-detail">
                        <span class="signal-detail-label">Strike:</span>
                        <span class="signal-detail-value">$${signal.strike.toFixed(2)}</span>
                    </div>
                    <div class="signal-detail">
                        <span class="signal-detail-label">Entry:</span>
                        <span class="signal-detail-value">$${signal.suggested_entry.toFixed(2)}</span>
                    </div>
                    <div class="signal-detail">
                        <span class="signal-detail-label">Target:</span>
                        <span class="signal-detail-value text-success">$${signal.target_price.toFixed(2)} (+${signal.target_profit_percent.toFixed(0)}%)</span>
                    </div>
                    <div class="signal-detail">
                        <span class="signal-detail-label">Stop:</span>
                        <span class="signal-detail-value text-danger">$${signal.stop_loss.toFixed(2)} (${signal.stop_loss_percent.toFixed(0)}%)</span>
                    </div>
                    <div class="signal-detail">
                        <span class="signal-detail-label">DTE:</span>
                        <span class="signal-detail-value">${signal.dte} days</span>
                    </div>
                    <div class="signal-detail">
                        <span class="signal-detail-label">Delta:</span>
                        <span class="signal-detail-value">${signal.delta.toFixed(2)}</span>
                    </div>
                    <div class="signal-detail">
                        <span class="signal-detail-label">IV Rank:</span>
                        <span class="signal-detail-value">${signal.iv_rank.toFixed(0)}%</span>
                    </div>
                </div>

                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color);">
                    <strong>Reasoning:</strong>
                    <p class="text-muted" style="margin-top: 0.5rem; font-size: 0.875rem;">${signal.reasoning}</p>
                </div>

                <div style="display: flex; gap: 0.75rem; margin-top: 1rem;">
                    <button class="btn btn-primary" id="quick-add-${signal.signal_id}" style="flex: 1;">
                        âž• Quick Add to Paper Trading
                    </button>
                    <button class="btn btn-success btn-sm" onclick="alert('Real trading coming soon!')">
                        ðŸš€ Trade Live
                    </button>
                </div>
            </div>
        `;
    },

    async quickAddToPaper(signal) {
        const btn = document.getElementById(`quick-add-${signal.signal_id}`);
        const originalText = btn.innerHTML;

        try {
            btn.innerHTML = 'â³ Adding...';
            btn.disabled = true;

            const response = await fetch('/api/paper/quick-add-signal', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(signal)
            });

            const result = await response.json();

            if (result.status === 'added') {
                btn.innerHTML = 'âœ… Added to Paper Trading!';
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-success');

                // Reload stats
                await this.loadStats();

                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.classList.remove('btn-success');
                    btn.classList.add('btn-primary');
                    btn.disabled = false;
                }, 2000);
            } else if (result.status === 'already_exists') {
                btn.innerHTML = 'âœ“ Already in Paper Trading';
                btn.disabled = true;
            }
        } catch (error) {
            console.error('Error adding to paper trading:', error);
            btn.innerHTML = 'âŒ Error';
            setTimeout(() => {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }, 2000);
        }
    },

    calculateMatchScore(signal) {
        // Load user preferences
        const saved = localStorage.getItem('tradefly_preferences');
        if (!saved) return 100; // No preferences = all signals match 100%

        const prefs = JSON.parse(saved);
        let score = 100;

        // DTE match (30 points)
        if (prefs.dtePreference === 'scalp' && signal.dte > 7) score -= 30;
        if (prefs.dtePreference === 'short' && (signal.dte < 7 || signal.dte > 30)) score -= 30;
        if (prefs.dtePreference === 'medium' && (signal.dte < 30 || signal.dte > 90)) score -= 30;
        if (prefs.dtePreference === 'leaps' && signal.dte < 90) score -= 30;

        // Delta match (25 points)
        const delta = Math.abs(signal.delta || 0);
        if (prefs.strikePreference === 'deep-itm' && delta < 0.80) score -= 25;
        if (prefs.strikePreference === 'slight-itm' && (delta < 0.55 || delta > 0.80)) score -= 25;
        if (prefs.strikePreference === 'atm' && (delta < 0.45 || delta > 0.55)) score -= 25;
        if (prefs.strikePreference === 'slight-otm' && (delta < 0.30 || delta > 0.45)) score -= 25;
        if (prefs.strikePreference === 'far-otm' && delta > 0.30) score -= 25;

        // Premium match (25 points)
        const premium = signal.suggested_entry || 0;
        if (prefs.premiumBudget === 'conservative' && premium > 2) score -= 25;
        if (prefs.premiumBudget === 'moderate' && (premium < 2 || premium > 5)) score -= 25;
        if (prefs.premiumBudget === 'aggressive' && (premium < 5 || premium > 10)) score -= 25;
        if (prefs.premiumBudget === 'high-roller' && premium < 10) score -= 25;

        // Confidence match (20 points)
        const confidence = (signal.confidence || 0) * 100;
        if (confidence < prefs.minConfidence) score -= 20;

        return Math.max(0, Math.round(score));
    }
};

// Initialize when page loads
ScalpingPage.init();
</script>

<style>
.match-badge {
    padding: 0.25rem 0.75rem;
    border-radius: 0.375rem;
    font-weight: 600;
    font-size: 0.875rem;
    white-space: nowrap;
}

.match-perfect {
    background: rgba(16, 185, 129, 0.2);
    color: var(--success-color);
    border: 1px solid var(--success-color);
}

.match-good {
    background: rgba(59, 130, 246, 0.2);
    color: var(--primary-color);
    border: 1px solid var(--primary-color);
}

.match-ok {
    background: rgba(245, 158, 11, 0.2);
    color: #f59e0b;
    border: 1px solid #f59e0b;
}

.match-poor {
    background: rgba(239, 68, 68, 0.2);
    color: var(--danger-color);
    border: 1px solid var(--danger-color);
}
</style>
